---
layout: post
title:  "App 1.0"
author: orta
categories: cocoapods app release
post_title_id:  "app"
---



<!-- more -->

<style>
#app {
  background: url(/assets/blog_img/app/app.jpg) no-repeat center center ;
  -webkit-background-size: cover;
  -moz-background-size: cover;
  -o-background-size: cover;
  background-size: cover;
}
</style>


### What's happening under the hood?

Let's take a look at the Xcode Project.

{% breaking_image /assets/blog_img/app/xcodeproj.png, /assets/blog_img/xcodeproj.png, class="image-zoom" %}

So let's talk about how the app works. It is three separate tools that work in combination to provide a seamless experience.

#### CocoaPods

The CocoaPods app, it provides an OS X GUI to common tasks for people who use CocoaPods. It also is the host to an entire OS environment required to use all of CocoaPods' features. It turns out there are quite a lot of dependencies for CocoaPods once you try to replicate the common user's environment.

In order to make it work seamlessly we bundle: `bzr`, `curl`, `git`, `mercurial`, `ncurses`, `openssl`, `pkg-config`, `ruby`, `scons`, `serf`, `subversion`, `yaml` and `zlib`. These are compiled dependencies that are inside the application bundle. In the Xcode Project above, they are contained in the `bundle` reference group.

{% breaking_image /assets/blog_img/app/resources.png, /assets/blog_img/resources.png %}

It's quite the setup in there. It's very similar to how Xcode hosts all of it's SDKs, compilers and apps (Instruments.app, iOS Simulator.app for example.) These folders represent a hosted environment which is well-contained and well tested. We provide the latest stable builds of these dependencies inside the app.

The GUI aspect of the app is built mainly in Swift and Objective-C when necessary. It uses all the fancy modern goodies available in the latest Cocoa APIs: NSViewControllers, Storyboards and XPC.

{% breaking_image /assets/blog_img/app/storyboards.png, /assets/blog_img/storyboards.png, class="image-zoom" %}

It's cleanly built using simple composition, and has been the source for quite a few people's first open source contribution. We keep a well stocked [issue cabinet](http://github.com/cocoapods/cocoapods-app/issues) with well marked out issues for people wanting to help out. I aim to always put up designs early for features, making it easy for people to contribute with a specification in mind.

#### pod

We doing plan  on replicating every feature of the command-line gem in the CocoaPods app. That's just not good usage of our time. Instead we offer a way to access the command-line interface with the version of CocoaPods that is inside CocoaPods.app. We do this in the same way Xcode does, by offering command line tools:

{% breaking_image /assets/blog_img/app/command-line-tools.png, /assets/blog_img/command-line-tools.png, class="image-zoom" %}

The `pod` command is a C [binstub](https://github.com/rbenv/rbenv/wiki/Understanding-binstubs) which uses the Core Services API in order to work independent of the CocoaPods.app which installed it. The binstub finds the embedded ruby `pod` command generated by RubyGems and passes along the same arguments. This means once you've installed it, you can move your app freely, and we don't need to update the C binstub. Ace.

As it has the same name, you don't need to change any scripts or your development flow in the terminal once installed. I've been using it as my main `pod` command for the last few months.

#### ReflectionService

The CocoaPods app needs to talk to the `pod` command provided by ruby. The simplest option is via [NSTask](http://www.raywenderlich.com/36537/nstask-tutorial), which will execute a command in a shell and output text to `STDIN` and `STERR`. This makes it easy to run commands, but it can be hard to deal with interactivity. It's effectively a one way communication pattern.

At one point we made a fork of [RubyCocoa](http://rubycocoa.github.io) that [supported Swift](https://github.com/alloy/RubyCocoa/tree/cocoapods-app-with-swift), but that was probably going to turn into a long road for something with not too much gain on our end. We negated the need for this by moving to communicate with Ruby over XPC, we call this the ReflectionService
